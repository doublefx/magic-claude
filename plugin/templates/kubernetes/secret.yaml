# NOTE: This is a template for Kubernetes Secrets
# In production, use External Secrets Operator, Sealed Secrets, or a secrets management solution
# NEVER commit actual secrets to version control

apiVersion: v1
kind: Secret
metadata:
  name: myapp-secrets
  labels:
    app: myapp
type: Opaque
stringData:
  # Database credentials (EXAMPLE - use real secret management in production)
  DB_USERNAME: "myapp_user"
  DB_PASSWORD: "REPLACE_WITH_ACTUAL_PASSWORD"

  # API keys (EXAMPLE)
  API_KEY: "REPLACE_WITH_ACTUAL_API_KEY"
  API_SECRET: "REPLACE_WITH_ACTUAL_API_SECRET"

  # JWT secret
  JWT_SECRET: "REPLACE_WITH_ACTUAL_JWT_SECRET"

  # Encryption keys
  ENCRYPTION_KEY: "REPLACE_WITH_ACTUAL_ENCRYPTION_KEY"

  # Third-party service credentials
  AWS_ACCESS_KEY_ID: "REPLACE_WITH_ACTUAL_AWS_KEY"
  AWS_SECRET_ACCESS_KEY: "REPLACE_WITH_ACTUAL_AWS_SECRET"

  # OAuth credentials
  OAUTH_CLIENT_ID: "REPLACE_WITH_ACTUAL_CLIENT_ID"
  OAUTH_CLIENT_SECRET: "REPLACE_WITH_ACTUAL_CLIENT_SECRET"

---
# TLS Secret (for HTTPS/ingress)
# Generate with: kubectl create secret tls myapp-tls --cert=path/to/tls.crt --key=path/to/tls.key
apiVersion: v1
kind: Secret
metadata:
  name: myapp-tls
  labels:
    app: myapp
type: kubernetes.io/tls
data:
  # Base64 encoded certificate and key
  tls.crt: LS0tLS1CRUdJTi... # REPLACE WITH ACTUAL CERTIFICATE
  tls.key: LS0tLS1CRUdJTi... # REPLACE WITH ACTUAL KEY

---
# Docker registry secret (for pulling private images)
# Generate with: kubectl create secret docker-registry myapp-registry-secret \
#   --docker-server=ghcr.io \
#   --docker-username=<username> \
#   --docker-password=<password> \
#   --docker-email=<email>
apiVersion: v1
kind: Secret
metadata:
  name: myapp-registry-secret
  labels:
    app: myapp
type: kubernetes.io/dockerconfigjson
data:
  .dockerconfigjson: eyJhdXRocyI6eyJnaGNyLmlvIjp7InVzZXJuYW1lIjoiUkVQTEFDRV9XSVRIX0FDVFVBTCIsInBhc3N3b3JkIjoiUkVQTEFDRV9XSVRIX0FDVFVBTCIsImVtYWlsIjoiUkVQTEFDRV9XSVRIX0FDVFVBTCIsImF1dGgiOiJSRVBMQUNFX1dJVEhfQUNUVUFMIn19fQ==

---
# RECOMMENDED: Use External Secrets Operator instead
# This integrates with AWS Secrets Manager, HashiCorp Vault, Google Secret Manager, etc.
apiVersion: external-secrets.io/v1beta1
kind: ExternalSecret
metadata:
  name: myapp-external-secret
  labels:
    app: myapp
spec:
  refreshInterval: 1h
  secretStoreRef:
    name: aws-secrets-manager
    kind: SecretStore
  target:
    name: myapp-secrets
    creationPolicy: Owner
  data:
  - secretKey: DB_PASSWORD
    remoteRef:
      key: myapp/database
      property: password

  - secretKey: API_KEY
    remoteRef:
      key: myapp/api
      property: key

  - secretKey: JWT_SECRET
    remoteRef:
      key: myapp/jwt
      property: secret

---
# SecretStore for External Secrets Operator (AWS Secrets Manager example)
apiVersion: external-secrets.io/v1beta1
kind: SecretStore
metadata:
  name: aws-secrets-manager
  labels:
    app: myapp
spec:
  provider:
    aws:
      service: SecretsManager
      region: us-east-1
      auth:
        secretRef:
          accessKeyIDSecretRef:
            name: aws-credentials
            key: access-key-id
          secretAccessKeySecretRef:
            name: aws-credentials
            key: secret-access-key

---
# RECOMMENDED: Use Sealed Secrets for GitOps
# Install: https://github.com/bitnami-labs/sealed-secrets
# Create with: kubeseal -f secret.yaml -w sealed-secret.yaml
apiVersion: bitnami.com/v1alpha1
kind: SealedSecret
metadata:
  name: myapp-sealed-secret
  labels:
    app: myapp
spec:
  encryptedData:
    DB_PASSWORD: AgA... # ENCRYPTED VALUE
    API_KEY: AgB... # ENCRYPTED VALUE
  template:
    metadata:
      name: myapp-secrets
      labels:
        app: myapp
    type: Opaque
